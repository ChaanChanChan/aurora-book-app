"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequelizeRepository = void 0;
const common_1 = require("@nestjs/common");
const sequelize_1 = require("sequelize");
const cleanDeep = require('clean-deep');
class SequelizeRepository {
    repository;
    criteria;
    aggregateName;
    mapper;
    auditingRunner;
    async paginate({ queryStatement = {}, constraint = {}, cQMetadata = undefined, } = {}) {
        const hookCountResponse = this.countStatementPaginateHook(constraint, cQMetadata);
        const total = await this.repository.count(this.criteria.implements(hookCountResponse.queryStatement, hookCountResponse.cQMetadata), cQMetadata?.repositoryOptions);
        const hookComposeResponse = this.composeStatementPaginateHook(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata);
        const { count, rows } = await this.repository.findAndCountAll(this.criteria.implements(hookComposeResponse.queryStatement, hookComposeResponse.cQMetadata), cQMetadata?.repositoryOptions);
        return {
            total,
            count,
            rows: this.mapper.mapModelsToAggregates(rows, cQMetadata),
        };
    }
    countStatementPaginateHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    composeStatementPaginateHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    async find({ queryStatement = {}, constraint = {}, cQMetadata = undefined, } = {}) {
        const hookResponse = this.composeStatementFindHook(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata);
        const model = await this.repository.findOne(this.criteria.implements(hookResponse.queryStatement, hookResponse.cQMetadata), cQMetadata?.repositoryOptions);
        if (!model)
            throw new common_1.NotFoundException(`${this.aggregateName} not found`);
        return this.mapper.mapModelToAggregate(model, cQMetadata);
    }
    composeStatementFindHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    async findById(id, { constraint = {}, cQMetadata = undefined, } = {}) {
        const hookResponse = this.composeStatementFindByIdHook(this.criteria.mergeQueryConstraintStatement({
            where: {
                id: id.value,
            },
        }, constraint), cQMetadata);
        const model = await this.repository.findOne(this.criteria.implements(hookResponse.queryStatement, hookResponse.cQMetadata), cQMetadata?.repositoryOptions);
        if (!model)
            throw new common_1.NotFoundException(`${this.aggregateName} with id: ${id.value}, not found`);
        return this.mapper.mapModelToAggregate(model, cQMetadata);
    }
    composeStatementFindByIdHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    async get({ queryStatement = {}, constraint = {}, cQMetadata = undefined, } = {}) {
        const hookResponse = this.composeStatementGetHook(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata);
        const models = await this.repository.findAll(this.criteria.implements(hookResponse.queryStatement, hookResponse.cQMetadata), cQMetadata?.repositoryOptions);
        return this.mapper.mapModelsToAggregates(models, cQMetadata);
    }
    composeStatementGetHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    async rawSQL({ rawSQL = undefined, cQMetadata = undefined, } = {}) {
        const models = await this.repository.sequelize.query(this.composeStatementRawSQLHook(rawSQL, cQMetadata), {
            ...cQMetadata?.repositoryOptions,
            type: sequelize_1.QueryTypes.SELECT,
        });
        return this.mapper.mapModelsToAggregates(models, cQMetadata);
    }
    composeStatementRawSQLHook(rawSQL, cQMetadata) { return rawSQL; }
    async count({ queryStatement = {}, constraint = {}, cQMetadata = undefined, } = {}) {
        const hookResponse = this.composeStatementCountHook(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata);
        const nRecords = await this.repository.count(this.criteria.implements(hookResponse.queryStatement, hookResponse.cQMetadata), cQMetadata?.repositoryOptions);
        return nRecords;
    }
    composeStatementCountHook(queryStatement, cQMetadata) { return { queryStatement, cQMetadata }; }
    async create(aggregate, { createOptions = undefined, dataFactory = (aggregate) => aggregate.toRepository(), finderQueryStatement = (aggregate) => ({ where: { id: aggregate['id']['value'] } }), } = {}) {
        const modelInDB = await this.repository.findOne(finderQueryStatement(aggregate));
        if (modelInDB)
            throw new common_1.ConflictException(`Error to create ${this.aggregateName}, the id ${aggregate['id']['value']} already exist in database`);
        try {
            if (createOptions?.auditing)
                createOptions.auditing.auditingRunner = this.auditingRunner;
            const model = await this.repository
                .create(dataFactory(aggregate), createOptions);
            this.createdAggregateHook(aggregate, model, createOptions);
        }
        catch (error) {
            throw new common_1.ConflictException(error.message);
        }
    }
    async createdAggregateHook(aggregate, model, createOptions) { }
    async insert(aggregates, { insertOptions = undefined, dataFactory = (aggregate) => aggregate.toRepository(), } = {}) {
        if (insertOptions?.auditing)
            insertOptions.auditing.auditingRunner = this.auditingRunner;
        await this.repository.bulkCreate(aggregates.map(item => dataFactory(item)), insertOptions);
        this.insertedAggregateHook(aggregates, insertOptions);
    }
    async insertedAggregateHook(aggregates, insertOptions) { }
    async updateById(aggregate, { updateByIdOptions = undefined, constraint = {}, cQMetadata = undefined, dataFactory = (aggregate) => aggregate.toRepository(), findArguments = { id: aggregate['id']['value'] }, } = {}) {
        const modelInDB = await this.repository.findOne(this.criteria.implements(this.criteria.mergeQueryConstraintStatement({
            where: findArguments,
        }, constraint), cQMetadata));
        if (!modelInDB)
            throw new common_1.NotFoundException(`${this.aggregateName} not found`);
        const LiteralObject = cleanDeep(dataFactory(aggregate), {
            nullValues: false,
            emptyStrings: false,
            emptyObjects: false,
            emptyArrays: false,
        });
        if (updateByIdOptions?.auditing)
            updateByIdOptions.auditing.auditingRunner = this.auditingRunner;
        const model = await modelInDB.update(LiteralObject, updateByIdOptions);
        this.updatedByIdAggregateHook(aggregate, model, updateByIdOptions);
    }
    async updatedByIdAggregateHook(aggregate, model, updateByIdOptions) { }
    async update(aggregate, { updateOptions = undefined, queryStatement = {}, constraint = {}, cQMetadata = undefined, dataFactory = (aggregate) => aggregate.toRepository(), } = {}) {
        if (!queryStatement ||
            !queryStatement.where ||
            updateOptions?.allRows)
            throw new common_1.BadRequestException('To update multiple records, you must define a where statement');
        const LiteralObject = cleanDeep(dataFactory(aggregate), {
            nullValues: false,
            emptyStrings: false,
            emptyObjects: false,
            emptyArrays: false,
        });
        if (updateOptions?.auditing)
            updateOptions.auditing.auditingRunner = this.auditingRunner;
        const model = await this.repository.update(LiteralObject, {
            ...this.criteria.implements(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata),
            ...updateOptions,
        });
        this.updatedAggregateHook(aggregate, model, updateOptions);
    }
    async updatedAggregateHook(aggregate, model, updateOptions) { }
    async upsert(aggregate, { upsertOptions = undefined, dataFactory = (aggregate) => aggregate.toRepository(), } = {}) {
        if (upsertOptions?.auditing)
            upsertOptions.auditing.auditingRunner = this.auditingRunner;
        await this.repository
            .upsert(dataFactory(aggregate), upsertOptions);
        this.upsertedAggregateHook(aggregate, upsertOptions);
    }
    async upsertedAggregateHook(aggregates, upsertOptions) { }
    async deleteById(id, { deleteOptions = undefined, constraint = {}, cQMetadata = undefined, } = {}) {
        const model = await this.repository.findOne(this.criteria.implements(this.criteria.mergeQueryConstraintStatement({
            where: {
                id: id.value,
            },
        }, constraint), cQMetadata));
        if (!model)
            throw new common_1.NotFoundException(`${this.aggregateName} not found`);
        if (deleteOptions?.auditing)
            deleteOptions.auditing.auditingRunner = this.auditingRunner;
        await model.destroy(deleteOptions);
    }
    async delete({ deleteOptions = undefined, queryStatement = {}, constraint = {}, cQMetadata = undefined, } = {}) {
        if (!queryStatement ||
            !queryStatement.where ||
            deleteOptions?.allRows)
            throw new common_1.BadRequestException('To delete multiple records, you must define a where statement');
        if (deleteOptions?.auditing)
            deleteOptions.auditing.auditingRunner = this.auditingRunner;
        await this.repository.destroy({
            ...this.criteria.implements(this.criteria.mergeQueryConstraintStatement(queryStatement, constraint), cQMetadata),
            ...deleteOptions,
        });
    }
}
exports.SequelizeRepository = SequelizeRepository;
