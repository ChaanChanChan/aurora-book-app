"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const uuid_1 = require("uuid");
const crypto = require("crypto");
const bcrypt = require("bcrypt");
const path = require("path");
const mime = require("mime");
const utc = require("dayjs/plugin/utc");
const timezone = require("dayjs/plugin/timezone");
const advancedFormat = require("dayjs/plugin/advancedFormat");
const dayjs = require("dayjs");
const _ = require("lodash");
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(advancedFormat);
class Utils {
    static now() {
        return dayjs();
    }
    static nowTimestamp() {
        return dayjs().format('YYYY-MM-DD H:mm:ss');
    }
    static nowDate() {
        return dayjs().format('YYYY-MM-DD');
    }
    static dateFromFormat(date, format = 'YYYY-MM-DD H:mm:ss') {
        return dayjs(date, format);
    }
    static sha1(data) {
        const generator = crypto.createHash('sha1');
        generator.update(data);
        return generator.digest('hex');
    }
    static uuid() {
        return (0, uuid_1.v4)();
    }
    static wait(time) {
        return new Promise(resolve => setTimeout(resolve, time));
    }
    static base64Encode(data) {
        return Buffer.from(data).toString('base64');
    }
    static base64Decode(data) {
        return Buffer.from(data, 'base64').toString('utf-8');
    }
    static diff(newObj, origObj) {
        const changes = (newObj, origObj) => {
            let arrayIndexCounter = 0;
            return _.transform(newObj, (result, value, key) => {
                if (!_.isEqual(value, origObj[key])) {
                    const resultKey = _.isArray(origObj) ? arrayIndexCounter++ : key;
                    result[resultKey] = (_.isObject(value) && _.isObject(origObj[key])) ? changes(value, origObj[key]) : value;
                }
            });
        };
        return changes(newObj, origObj);
    }
    static arrayRemoveItem(arr, value) {
        let arrValues;
        if (Array.isArray(value)) {
            arrValues = value;
        }
        else {
            if (value) {
                arrValues = [value];
            }
            else {
                return [];
            }
        }
        return arr.filter(ele => !arrValues.includes(ele));
    }
    static arraysHasSameValues(arr1, arr2) {
        if (arr1.length === arr2.length) {
            return arr1.every(element => {
                if (arr2.includes(element))
                    return true;
                return false;
            });
        }
        return false;
    }
    static arrayGroup(arr, n) {
        const result = [];
        for (let i = 0; i < arr.length; i += n) {
            result.push(arr.slice(i, i + n));
        }
        return result;
    }
    static deepMapKeys(obj, fn, getKeys = Reflect.ownKeys) {
        return Array.isArray(obj)
            ? obj.map(val => Utils.deepMapKeys(val, fn))
            : typeof obj === 'object'
                ? getKeys(obj).reduce((acc, current) => {
                    const key = fn(current);
                    const val = obj[current];
                    acc[key] = val !== null && typeof val === 'object' ? Utils.deepMapKeys(val, fn) : val;
                    return acc;
                }, {})
                : obj;
    }
    static deepMapKeysOperators(obj, fn) {
        return Array.isArray(obj) ?
            obj.map(val => Utils.deepMapKeysOperators(val, fn)) :
            typeof obj === 'object' &&
                obj.constructor.name !== 'Fn' &&
                obj.constructor.name !== 'Cast' ?
                Object.keys(obj).reduce((acc, current) => {
                    const key = fn(current);
                    const val = obj[current];
                    acc[key] = val !== null && typeof val === 'object' ? Utils.deepMapKeysOperators(val, fn) : val;
                    return acc;
                }, {})
                : obj;
    }
    static deepMapValues(obj, fn) {
        if (Array.isArray(obj)) {
            return obj.map(function (val, key) {
                return (typeof val === 'object') ? Utils.deepMapValues(val, fn) : fn(val, key);
            });
        }
        else if (typeof obj === 'object') {
            const res = obj === null ? null : {};
            for (const key in obj) {
                const val = obj[key];
                if (typeof val === 'object') {
                    res[key] = Utils.deepMapValues(val, fn);
                }
                else {
                    res[key] = fn(val, key);
                }
            }
            return res;
        }
        else {
            return obj;
        }
    }
    static hash(password, saltRounds = 10) {
        return bcrypt.hashSync(password, saltRounds);
    }
    static mimeFromExtension(extension) {
        extension = extension.toLowerCase().replace(/\./g, '');
        return mime.getType(extension);
    }
    static isImageMime(mime) {
        switch (mime) {
            case 'image/gif':
            case 'image/jpeg':
            case 'image/pjpeg':
            case 'image/png':
            case 'image/svg+xml':
                return true;
                break;
            default:
                return false;
        }
    }
    static randomString(length, chars) {
        let mask = '';
        if (chars.indexOf('a') > -1)
            mask += 'abcdefghijklmnopqrstuvwxyz';
        if (chars.indexOf('A') > -1)
            mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        if (chars.indexOf('#') > -1)
            mask += '0123456789';
        if (chars.indexOf('!') > -1)
            mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
        let result = '';
        for (let i = length; i > 0; --i)
            result += mask[Math.floor(Math.random() * mask.length)];
        return result;
    }
    static basePath(...relativePath) {
        return path.join(process.cwd(), ...relativePath);
    }
    static asset(...relativePath) {
        return relativePath.join('/');
    }
    static isValidJson(json) {
        try {
            JSON.parse(json);
        }
        catch (e) {
            return false;
        }
        return true;
    }
}
exports.Utils = Utils;
